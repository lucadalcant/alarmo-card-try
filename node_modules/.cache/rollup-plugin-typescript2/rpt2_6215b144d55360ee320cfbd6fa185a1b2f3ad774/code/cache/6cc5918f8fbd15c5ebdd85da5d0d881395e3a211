{"code":"import { __decorate } from \"tslib\";\nimport { LitElement, html, css } from 'lit';\nimport { property } from 'lit/decorators.js';\nimport { ICONS, PENDING_STATES } from '../const';\nimport { fetchCountdown } from '../data/websockets';\nclass AlarmoStateBadge extends LitElement {\n    constructor() {\n        super(...arguments);\n        this.duration = 0;\n        this.datetime = null;\n        this.timer = 0;\n    }\n    shouldUpdate(changedProps) {\n        if (!changedProps.size)\n            return true;\n        const oldHass = changedProps.get('hass');\n        if (!oldHass || oldHass.themes !== this.hass.themes || oldHass.language !== this.hass.language)\n            return true;\n        if (oldHass.states[this.entity].state !== this.hass.states[this.entity].state ||\n            oldHass.states[this.entity].attributes.delay !== this.hass.states[this.entity].attributes.delay) {\n            const oldState = oldHass.states[this.entity].state;\n            const newState = this.hass.states[this.entity].state;\n            if (PENDING_STATES.includes(newState))\n                this.startTimer();\n            else if (PENDING_STATES.includes(oldState))\n                this.stopTimer();\n            return true;\n        }\n        return false;\n    }\n    firstUpdated() {\n        const state = this.hass.states[this.entity].state;\n        if (PENDING_STATES.includes(state))\n            this.startTimer();\n    }\n    async startTimer() {\n        clearInterval(this.timer);\n        fetchCountdown(this.hass, this.entity)\n            .then((countdownConfig) => {\n            this.duration = countdownConfig.delay;\n            this.datetime = new Date(new Date().getTime() + countdownConfig.remaining * 1000);\n        })\n            .catch((_e) => { });\n        this.timer = window.setInterval(() => {\n            this.requestUpdate();\n        }, 1000);\n    }\n    stopTimer() {\n        clearInterval(this.timer);\n        this.datetime = null;\n        this.duration = 0;\n    }\n    getRemaining() {\n        if (!this.datetime)\n            return 0;\n        const seconds = (this.datetime.getTime() - new Date().getTime()) / 1000;\n        if (seconds < 0) {\n            clearInterval(this.timer);\n            return 0;\n        }\n        return seconds;\n    }\n    getFraction() {\n        if (!this.duration)\n            return 1;\n        return (Math.round(this.getRemaining()) - 1) / this.duration;\n    }\n    _stateValue(state) {\n        if (this.datetime && this.duration) {\n            return html ` ${Math.max(Math.round(this.getRemaining()), 0)} `;\n        }\n        else {\n            return html ` <ha-icon .icon=${ICONS[state]}></ha-icon> `;\n        }\n    }\n    render() {\n        let c = 50;\n        let r = 45;\n        let arcLength = 2 * Math.PI * r;\n        const stateObj = this.hass.states[this.entity];\n        const timerRunning = this.datetime && this.duration;\n        return html `\n      <svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\">\n        <g class=\"track ${stateObj.state.split('_').shift()} ${timerRunning ? 'timer' : ''}\">\n          <circle cx=\"${c}\" cy=\"${c}\" r=\"${r}\"></circle>\n          <path\n            stroke-dasharray=\"${(this.getFraction() * arcLength).toFixed(2)} ${arcLength.toFixed(2)}\"\n            class=\"remaining\"\n            d=\"\n              M ${c}, ${c}\n              m -${r}, 0\n              a ${r},${r} 0 1,0 90,0\n              a ${r},${r} 0 1,0 -90,0\n            \"\n          ></path>\n        </g>\n      </svg>\n      <div class=\"overlay ${stateObj.state.split('_').shift()} ${timerRunning ? 'timer' : ''}\">\n        <div class=\"value\">${this._stateValue(stateObj.state)}</div>\n      </div>\n    `;\n    }\n    static get styles() {\n        return css `\n      :host {\n        width: 60px;\n        height: 60px;\n        cursor: pointer;\n      }\n      svg {\n        width: 100%;\n        height: 100%;\n        display: block;\n        transform: rotateZ(90deg) scale(1, -1);\n      }\n      .track {\n        stroke-width: 4px;\n        stroke-linecap: round;\n        stroke: var(--disabled-text-color);\n        fill: none;\n      }\n      .track .remaining {\n        transition: 0.3s linear stroke;\n        stroke: var(--alarm-state-color);\n      }\n      .track.arming .remaining,\n      .track.pending .remaining {\n        transition: 1s linear stroke-dasharray;\n      }\n      .overlay {\n        position: absolute;\n        margin-top: -60px;\n        margin-left: 0;\n        width: 60px;\n        height: 60px;\n        font-size: 1.5em;\n        white-space: nowrap;\n      }\n      .value {\n        overflow: hidden;\n        text-overflow: ellipsis;\n        text-align: center;\n        color: var(--alarm-state-color);\n        transition: 0.3s linear color;\n        display: flex;\n        flex: 1;\n        height: 100%;\n        align-items: center;\n        justify-content: center;\n        font-weight: 500;\n      }\n      .value ha-icon {\n        --mdc-icon-size: 1.2em;\n      }\n      .disarmed,\n      .armed {\n        animation: none;\n      }\n      .triggered,\n      .arming,\n      .pending {\n        animation: pulse 1s infinite;\n      }\n      .arming.timer,\n      .pending.timer {\n        animation: none;\n      }\n      @keyframes pulse {\n        0% {\n          opacity: 1;\n        }\n        50% {\n          opacity: 0;\n        }\n        100% {\n          opacity: 1;\n        }\n      }\n    `;\n    }\n}\n__decorate([\n    property()\n], AlarmoStateBadge.prototype, \"hass\", void 0);\n__decorate([\n    property()\n], AlarmoStateBadge.prototype, \"entity\", void 0);\ncustomElements.define('alarmo-state-badge', AlarmoStateBadge);\n","references":["/home/ubuntu/Documents/GitHub/alarmo-card/node_modules/lit/index.d.ts","/home/ubuntu/Documents/GitHub/alarmo-card/node_modules/lit/decorators.d.ts","/home/ubuntu/Documents/GitHub/alarmo-card/node_modules/custom-card-helpers/dist/index.d.ts","/home/ubuntu/Documents/GitHub/alarmo-card/src/const.ts","/home/ubuntu/Documents/GitHub/alarmo-card/src/data/websockets.ts"]}
